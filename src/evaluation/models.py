"""
Data models for the Partner Evaluation Framework.

This module defines the core data structures used throughout the evaluation process,
including evaluation dimensions, weights, scores, and results.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from enum import Enum
from datetime import datetime


class EvaluationDimension(str, Enum):
    """Standard evaluation dimensions for partner assessment."""

    MARKET_COMPATIBILITY = "market_compatibility"
    FINANCIAL_HEALTH = "financial_health"
    TECHNICAL_SYNERGY = "technical_synergy"
    OPERATIONAL_CAPACITY = "operational_capacity"
    GEOGRAPHIC_COVERAGE = "geographic_coverage"
    STRATEGIC_ALIGNMENT = "strategic_alignment"
    CULTURAL_FIT = "cultural_fit"
    RESOURCE_COMPLEMENTARITY = "resource_complementarity"
    GROWTH_POTENTIAL = "growth_potential"
    RISK_PROFILE = "risk_profile"

    @classmethod
    def get_description(cls, dimension: "EvaluationDimension") -> str:
        """Get human-readable description for a dimension."""
        descriptions = {
            cls.MARKET_COMPATIBILITY: "Alignment of target markets, customer segments, and market positioning",
            cls.FINANCIAL_HEALTH: "Financial stability, revenue growth, funding status, and investment capacity",
            cls.TECHNICAL_SYNERGY: "Technology stack compatibility, technical capabilities, and integration potential",
            cls.OPERATIONAL_CAPACITY: "Supply chain, logistics, manufacturing, and operational excellence",
            cls.GEOGRAPHIC_COVERAGE: "Geographic presence, distribution networks, and regional expertise",
            cls.STRATEGIC_ALIGNMENT: "Alignment of business goals, vision, and long-term strategy",
            cls.CULTURAL_FIT: "Organizational culture compatibility and collaboration potential",
            cls.RESOURCE_COMPLEMENTARITY: "Complementary resources, capabilities, and expertise",
            cls.GROWTH_POTENTIAL: "Potential for mutual growth and scalability of partnership",
            cls.RISK_PROFILE: "Risk factors, dependencies, and potential challenges",
        }
        return descriptions.get(dimension, "")


@dataclass
class DimensionWeight:
    """Weight configuration for an evaluation dimension."""

    dimension: EvaluationDimension
    weight: float  # 0.0 to 1.0
    priority: int  # 1 = highest priority
    rationale: str = ""

    def __post_init__(self):
        if not 0.0 <= self.weight <= 1.0:
            raise ValueError(f"Weight must be between 0.0 and 1.0, got {self.weight}")
        if self.priority < 1:
            raise ValueError(f"Priority must be >= 1, got {self.priority}")


@dataclass
class EvaluationStrategy:
    """
    Strategy configuration for partner evaluation.

    Generated by the Planner Agent and confirmed by the user.
    """

    dimensions: List[DimensionWeight]
    total_candidates: int
    top_k: int = 5  # Number of top candidates to return
    exclusion_criteria: List[str] = field(default_factory=list)
    inclusion_criteria: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    confirmed_by_user: bool = False
    user_modifications: List[str] = field(default_factory=list)

    def __post_init__(self):
        # Validate weights sum to approximately 1.0
        total_weight = sum(d.weight for d in self.dimensions)
        if not 0.99 <= total_weight <= 1.01:
            raise ValueError(f"Dimension weights must sum to 1.0, got {total_weight}")

    def get_dimension_weight(self, dimension: EvaluationDimension) -> float:
        """Get the weight for a specific dimension."""
        for dw in self.dimensions:
            if dw.dimension == dimension:
                return dw.weight
        return 0.0

    def to_dict(self) -> Dict[str, Any]:
        """Convert strategy to dictionary format."""
        return {
            "dimensions": [
                {
                    "dimension": dw.dimension.value,
                    "weight": dw.weight,
                    "priority": dw.priority,
                    "rationale": dw.rationale,
                    "description": EvaluationDimension.get_description(dw.dimension),
                }
                for dw in sorted(self.dimensions, key=lambda x: x.priority)
            ],
            "total_candidates": self.total_candidates,
            "top_k": self.top_k,
            "exclusion_criteria": self.exclusion_criteria,
            "inclusion_criteria": self.inclusion_criteria,
            "confirmed_by_user": self.confirmed_by_user,
            "user_modifications": self.user_modifications,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "EvaluationStrategy":
        """Create strategy from dictionary format."""
        dimensions = [
            DimensionWeight(
                dimension=EvaluationDimension(d["dimension"]),
                weight=d["weight"],
                priority=d["priority"],
                rationale=d.get("rationale", ""),
            )
            for d in data["dimensions"]
        ]
        return cls(
            dimensions=dimensions,
            total_candidates=data["total_candidates"],
            top_k=data.get("top_k", 5),
            exclusion_criteria=data.get("exclusion_criteria", []),
            inclusion_criteria=data.get("inclusion_criteria", []),
            confirmed_by_user=data.get("confirmed_by_user", False),
            user_modifications=data.get("user_modifications", []),
        )


@dataclass
class DimensionScore:
    """Score for a single evaluation dimension."""

    dimension: EvaluationDimension
    score: float  # 0.0 to 100.0
    confidence: float  # 0.0 to 1.0
    evidence: List[str] = field(default_factory=list)
    reasoning: str = ""
    data_sources: List[str] = field(default_factory=list)

    def __post_init__(self):
        if not 0.0 <= self.score <= 100.0:
            raise ValueError(f"Score must be between 0.0 and 100.0, got {self.score}")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")

    @property
    def weighted_score(self) -> float:
        """Score adjusted by confidence."""
        return self.score * self.confidence


@dataclass
class CandidateEvaluation:
    """Complete evaluation result for a single candidate."""

    candidate_id: str
    candidate_name: str
    candidate_info: Dict[str, Any]
    dimension_scores: List[DimensionScore]
    final_score: float  # Weighted aggregate score (0-100)
    rank: int
    strengths: List[str] = field(default_factory=list)
    weaknesses: List[str] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    flags: List[str] = field(default_factory=list)  # Warnings or special notes
    evaluation_timestamp: datetime = field(default_factory=datetime.now)

    def get_dimension_score(self, dimension: EvaluationDimension) -> Optional[DimensionScore]:
        """Get the score for a specific dimension."""
        for ds in self.dimension_scores:
            if ds.dimension == dimension:
                return ds
        return None

    def to_dict(self) -> Dict[str, Any]:
        """Convert evaluation to dictionary format."""
        return {
            "candidate_id": self.candidate_id,
            "candidate_name": self.candidate_name,
            "candidate_info": self.candidate_info,
            "dimension_scores": [
                {
                    "dimension": ds.dimension.value,
                    "dimension_name": ds.dimension.value.replace("_", " ").title(),
                    "score": ds.score,
                    "confidence": ds.confidence,
                    "weighted_score": ds.weighted_score,
                    "evidence": ds.evidence,
                    "reasoning": ds.reasoning,
                    "data_sources": ds.data_sources,
                }
                for ds in self.dimension_scores
            ],
            "final_score": self.final_score,
            "rank": self.rank,
            "strengths": self.strengths,
            "weaknesses": self.weaknesses,
            "recommendations": self.recommendations,
            "flags": self.flags,
            "evaluation_timestamp": self.evaluation_timestamp.isoformat(),
        }


@dataclass
class EvaluationResult:
    """Complete result of the evaluation process."""

    strategy: EvaluationStrategy
    evaluations: List[CandidateEvaluation]
    total_evaluated: int
    top_candidates: List[CandidateEvaluation]
    summary: str
    insights: List[str] = field(default_factory=list)
    conflicts_resolved: List[Dict[str, Any]] = field(default_factory=list)
    evaluation_metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary format."""
        return {
            "strategy": self.strategy.to_dict(),
            "evaluations": [e.to_dict() for e in self.evaluations],
            "total_evaluated": self.total_evaluated,
            "top_candidates": [e.to_dict() for e in self.top_candidates],
            "summary": self.summary,
            "insights": self.insights,
            "conflicts_resolved": self.conflicts_resolved,
            "evaluation_metadata": self.evaluation_metadata,
        }

    def get_candidate_by_rank(self, rank: int) -> Optional[CandidateEvaluation]:
        """Get candidate by their rank."""
        for candidate in self.evaluations:
            if candidate.rank == rank:
                return candidate
        return None

    def get_candidates_by_dimension(
        self, dimension: EvaluationDimension, min_score: float = 0.0
    ) -> List[CandidateEvaluation]:
        """Get candidates sorted by a specific dimension score."""
        candidates_with_scores = []
        for candidate in self.evaluations:
            dim_score = candidate.get_dimension_score(dimension)
            if dim_score and dim_score.score >= min_score:
                candidates_with_scores.append((candidate, dim_score.score))

        candidates_with_scores.sort(key=lambda x: x[1], reverse=True)
        return [c for c, _ in candidates_with_scores]


@dataclass
class RefinementRequest:
    """User request to refine evaluation results."""

    action: str  # "exclude", "include", "adjust_weight", "rerank", "focus"
    parameters: Dict[str, Any]
    reason: str = ""

    @classmethod
    def exclude_candidate(cls, candidate_id: str, reason: str = "") -> "RefinementRequest":
        """Create request to exclude a specific candidate."""
        return cls(
            action="exclude",
            parameters={"candidate_id": candidate_id},
            reason=reason,
        )

    @classmethod
    def adjust_dimension_weight(
        cls, dimension: EvaluationDimension, new_weight: float, reason: str = ""
    ) -> "RefinementRequest":
        """Create request to adjust a dimension's weight."""
        return cls(
            action="adjust_weight",
            parameters={"dimension": dimension.value, "new_weight": new_weight},
            reason=reason,
        )

    @classmethod
    def focus_on_dimension(
        cls, dimension: EvaluationDimension, reason: str = ""
    ) -> "RefinementRequest":
        """Create request to focus more on a specific dimension."""
        return cls(
            action="focus",
            parameters={"dimension": dimension.value},
            reason=reason,
        )


@dataclass
class StartupProfile:
    """Startup profile for evaluation context."""

    name: str
    industry: str
    stage: str  # "Seed", "Series A", etc.
    tech_stack: List[str] = field(default_factory=list)
    team_size: Optional[int] = None
    location: str = ""
    description: str = ""
    partner_needs: str = ""
    preferred_geography: List[str] = field(default_factory=list)
    exclusion_criteria: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            "name": self.name,
            "industry": self.industry,
            "stage": self.stage,
            "tech_stack": self.tech_stack,
            "team_size": self.team_size,
            "location": self.location,
            "description": self.description,
            "partner_needs": self.partner_needs,
            "preferred_geography": self.preferred_geography,
            "exclusion_criteria": self.exclusion_criteria,
        }